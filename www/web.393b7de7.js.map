{"mappings":"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","sources":["<anon>","node_modules/@capacitor/local-notifications/dist/esm/web.js","node_modules/@capacitor/local-notifications/src/web.ts"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    var parcelRequire = $parcel$global[\"parcelRequirea81d\"];\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"b0j91\", function(module, exports) {\n\n$parcel$export(module.exports, \"LocalNotificationsWeb\", () => $802e8b7ef2c3f5ab$export$e6460242ce1a3bfe);\n\nvar $gJCIb = parcelRequire(\"gJCIb\");\nclass $802e8b7ef2c3f5ab$export$e6460242ce1a3bfe extends (0, $gJCIb.WebPlugin) {\n    constructor(){\n        super(...arguments);\n        this.pending = [];\n        this.deliveredNotifications = [];\n        this.hasNotificationSupport = ()=>{\n            if (!('Notification' in window) || !Notification.requestPermission) return false;\n            if (Notification.permission !== 'granted') // don't test for `new Notification` if permission has already been granted\n            // otherwise this sends a real notification on supported browsers\n            try {\n                new Notification('');\n            } catch (e) {\n                if (e.name == 'TypeError') return false;\n            }\n            return true;\n        };\n    }\n    async getDeliveredNotifications() {\n        const deliveredSchemas = [];\n        for (const notification of this.deliveredNotifications){\n            const deliveredSchema = {\n                title: notification.title,\n                id: parseInt(notification.tag),\n                body: notification.body\n            };\n            deliveredSchemas.push(deliveredSchema);\n        }\n        return {\n            notifications: deliveredSchemas\n        };\n    }\n    async removeDeliveredNotifications(delivered) {\n        for (const toRemove of delivered.notifications){\n            const found = this.deliveredNotifications.find((n)=>n.tag === String(toRemove.id));\n            found === null || found === void 0 || found.close();\n            this.deliveredNotifications = this.deliveredNotifications.filter(()=>!found);\n        }\n    }\n    async removeAllDeliveredNotifications() {\n        for (const notification of this.deliveredNotifications)notification.close();\n        this.deliveredNotifications = [];\n    }\n    async createChannel() {\n        throw this.unimplemented('Not implemented on web.');\n    }\n    async deleteChannel() {\n        throw this.unimplemented('Not implemented on web.');\n    }\n    async listChannels() {\n        throw this.unimplemented('Not implemented on web.');\n    }\n    async schedule(options) {\n        if (!this.hasNotificationSupport()) throw this.unavailable('Notifications not supported in this browser.');\n        for (const notification of options.notifications)this.sendNotification(notification);\n        return {\n            notifications: options.notifications.map((notification)=>({\n                    id: notification.id\n                }))\n        };\n    }\n    async getPending() {\n        return {\n            notifications: this.pending\n        };\n    }\n    async registerActionTypes() {\n        throw this.unimplemented('Not implemented on web.');\n    }\n    async cancel(pending) {\n        this.pending = this.pending.filter((notification)=>!pending.notifications.find((n)=>n.id === notification.id));\n    }\n    async areEnabled() {\n        const { display: display } = await this.checkPermissions();\n        return {\n            value: display === 'granted'\n        };\n    }\n    async changeExactNotificationSetting() {\n        throw this.unimplemented('Not implemented on web.');\n    }\n    async checkExactNotificationSetting() {\n        throw this.unimplemented('Not implemented on web.');\n    }\n    async requestPermissions() {\n        if (!this.hasNotificationSupport()) throw this.unavailable('Notifications not supported in this browser.');\n        const display = this.transformNotificationPermission(await Notification.requestPermission());\n        return {\n            display: display\n        };\n    }\n    async checkPermissions() {\n        if (!this.hasNotificationSupport()) throw this.unavailable('Notifications not supported in this browser.');\n        const display = this.transformNotificationPermission(Notification.permission);\n        return {\n            display: display\n        };\n    }\n    transformNotificationPermission(permission) {\n        switch(permission){\n            case 'granted':\n                return 'granted';\n            case 'denied':\n                return 'denied';\n            default:\n                return 'prompt';\n        }\n    }\n    sendPending() {\n        var _a;\n        const toRemove = [];\n        const now = new Date().getTime();\n        for (const notification of this.pending)if (((_a = notification.schedule) === null || _a === void 0 ? void 0 : _a.at) && notification.schedule.at.getTime() <= now) {\n            this.buildNotification(notification);\n            toRemove.push(notification);\n        }\n        this.pending = this.pending.filter((notification)=>!toRemove.find((n)=>n === notification));\n    }\n    sendNotification(notification) {\n        var _a;\n        if ((_a = notification.schedule) === null || _a === void 0 ? void 0 : _a.at) {\n            const diff = notification.schedule.at.getTime() - new Date().getTime();\n            this.pending.push(notification);\n            setTimeout(()=>{\n                this.sendPending();\n            }, diff);\n            return;\n        }\n        this.buildNotification(notification);\n    }\n    buildNotification(notification) {\n        const localNotification = new Notification(notification.title, {\n            body: notification.body,\n            tag: String(notification.id)\n        });\n        localNotification.addEventListener('click', this.onClick.bind(this, notification), false);\n        localNotification.addEventListener('show', this.onShow.bind(this, notification), false);\n        localNotification.addEventListener('close', ()=>{\n            this.deliveredNotifications = this.deliveredNotifications.filter(()=>!this);\n        }, false);\n        this.deliveredNotifications.push(localNotification);\n        return localNotification;\n    }\n    onClick(notification) {\n        const data = {\n            actionId: 'tap',\n            notification: notification\n        };\n        this.notifyListeners('localNotificationActionPerformed', data);\n    }\n    onShow(notification) {\n        this.notifyListeners('localNotificationReceived', notification);\n    }\n}\n\n});\n\n\n//# sourceMappingURL=web.393b7de7.js.map\n","import { WebPlugin } from '@capacitor/core';\nexport class LocalNotificationsWeb extends WebPlugin {\n    constructor() {\n        super(...arguments);\n        this.pending = [];\n        this.deliveredNotifications = [];\n        this.hasNotificationSupport = () => {\n            if (!('Notification' in window) || !Notification.requestPermission) {\n                return false;\n            }\n            if (Notification.permission !== 'granted') {\n                // don't test for `new Notification` if permission has already been granted\n                // otherwise this sends a real notification on supported browsers\n                try {\n                    new Notification('');\n                }\n                catch (e) {\n                    if (e.name == 'TypeError') {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        };\n    }\n    async getDeliveredNotifications() {\n        const deliveredSchemas = [];\n        for (const notification of this.deliveredNotifications) {\n            const deliveredSchema = {\n                title: notification.title,\n                id: parseInt(notification.tag),\n                body: notification.body,\n            };\n            deliveredSchemas.push(deliveredSchema);\n        }\n        return {\n            notifications: deliveredSchemas,\n        };\n    }\n    async removeDeliveredNotifications(delivered) {\n        for (const toRemove of delivered.notifications) {\n            const found = this.deliveredNotifications.find(n => n.tag === String(toRemove.id));\n            found === null || found === void 0 ? void 0 : found.close();\n            this.deliveredNotifications = this.deliveredNotifications.filter(() => !found);\n        }\n    }\n    async removeAllDeliveredNotifications() {\n        for (const notification of this.deliveredNotifications) {\n            notification.close();\n        }\n        this.deliveredNotifications = [];\n    }\n    async createChannel() {\n        throw this.unimplemented('Not implemented on web.');\n    }\n    async deleteChannel() {\n        throw this.unimplemented('Not implemented on web.');\n    }\n    async listChannels() {\n        throw this.unimplemented('Not implemented on web.');\n    }\n    async schedule(options) {\n        if (!this.hasNotificationSupport()) {\n            throw this.unavailable('Notifications not supported in this browser.');\n        }\n        for (const notification of options.notifications) {\n            this.sendNotification(notification);\n        }\n        return {\n            notifications: options.notifications.map(notification => ({\n                id: notification.id,\n            })),\n        };\n    }\n    async getPending() {\n        return {\n            notifications: this.pending,\n        };\n    }\n    async registerActionTypes() {\n        throw this.unimplemented('Not implemented on web.');\n    }\n    async cancel(pending) {\n        this.pending = this.pending.filter(notification => !pending.notifications.find(n => n.id === notification.id));\n    }\n    async areEnabled() {\n        const { display } = await this.checkPermissions();\n        return {\n            value: display === 'granted',\n        };\n    }\n    async changeExactNotificationSetting() {\n        throw this.unimplemented('Not implemented on web.');\n    }\n    async checkExactNotificationSetting() {\n        throw this.unimplemented('Not implemented on web.');\n    }\n    async requestPermissions() {\n        if (!this.hasNotificationSupport()) {\n            throw this.unavailable('Notifications not supported in this browser.');\n        }\n        const display = this.transformNotificationPermission(await Notification.requestPermission());\n        return { display };\n    }\n    async checkPermissions() {\n        if (!this.hasNotificationSupport()) {\n            throw this.unavailable('Notifications not supported in this browser.');\n        }\n        const display = this.transformNotificationPermission(Notification.permission);\n        return { display };\n    }\n    transformNotificationPermission(permission) {\n        switch (permission) {\n            case 'granted':\n                return 'granted';\n            case 'denied':\n                return 'denied';\n            default:\n                return 'prompt';\n        }\n    }\n    sendPending() {\n        var _a;\n        const toRemove = [];\n        const now = new Date().getTime();\n        for (const notification of this.pending) {\n            if (((_a = notification.schedule) === null || _a === void 0 ? void 0 : _a.at) &&\n                notification.schedule.at.getTime() <= now) {\n                this.buildNotification(notification);\n                toRemove.push(notification);\n            }\n        }\n        this.pending = this.pending.filter(notification => !toRemove.find(n => n === notification));\n    }\n    sendNotification(notification) {\n        var _a;\n        if ((_a = notification.schedule) === null || _a === void 0 ? void 0 : _a.at) {\n            const diff = notification.schedule.at.getTime() - new Date().getTime();\n            this.pending.push(notification);\n            setTimeout(() => {\n                this.sendPending();\n            }, diff);\n            return;\n        }\n        this.buildNotification(notification);\n    }\n    buildNotification(notification) {\n        const localNotification = new Notification(notification.title, {\n            body: notification.body,\n            tag: String(notification.id),\n        });\n        localNotification.addEventListener('click', this.onClick.bind(this, notification), false);\n        localNotification.addEventListener('show', this.onShow.bind(this, notification), false);\n        localNotification.addEventListener('close', () => {\n            this.deliveredNotifications = this.deliveredNotifications.filter(() => !this);\n        }, false);\n        this.deliveredNotifications.push(localNotification);\n        return localNotification;\n    }\n    onClick(notification) {\n        const data = {\n            actionId: 'tap',\n            notification,\n        };\n        this.notifyListeners('localNotificationActionPerformed', data);\n    }\n    onShow(notification) {\n        this.notifyListeners('localNotificationReceived', notification);\n    }\n}\n//# sourceMappingURL=web.js.map","import { WebPlugin } from '@capacitor/core';\nimport type { PermissionState } from '@capacitor/core';\n\nimport type {\n  DeliveredNotifications,\n  EnabledResult,\n  ListChannelsResult,\n  LocalNotificationSchema,\n  LocalNotificationsPlugin,\n  PendingResult,\n  PermissionStatus,\n  ScheduleOptions,\n  ScheduleResult,\n  SettingsPermissionStatus,\n} from './definitions';\n\nexport class LocalNotificationsWeb\n  extends WebPlugin\n  implements LocalNotificationsPlugin\n{\n  protected pending: LocalNotificationSchema[] = [];\n  protected deliveredNotifications: Notification[] = [];\n\n  async getDeliveredNotifications(): Promise<DeliveredNotifications> {\n    const deliveredSchemas = [];\n    for (const notification of this.deliveredNotifications) {\n      const deliveredSchema: LocalNotificationSchema = {\n        title: notification.title,\n        id: parseInt(notification.tag),\n        body: notification.body,\n      };\n      deliveredSchemas.push(deliveredSchema);\n    }\n    return {\n      notifications: deliveredSchemas,\n    };\n  }\n  async removeDeliveredNotifications(\n    delivered: DeliveredNotifications,\n  ): Promise<void> {\n    for (const toRemove of delivered.notifications) {\n      const found = this.deliveredNotifications.find(\n        n => n.tag === String(toRemove.id),\n      );\n      found?.close();\n      this.deliveredNotifications = this.deliveredNotifications.filter(\n        () => !found,\n      );\n    }\n  }\n  async removeAllDeliveredNotifications(): Promise<void> {\n    for (const notification of this.deliveredNotifications) {\n      notification.close();\n    }\n    this.deliveredNotifications = [];\n  }\n  async createChannel(): Promise<void> {\n    throw this.unimplemented('Not implemented on web.');\n  }\n\n  async deleteChannel(): Promise<void> {\n    throw this.unimplemented('Not implemented on web.');\n  }\n\n  async listChannels(): Promise<ListChannelsResult> {\n    throw this.unimplemented('Not implemented on web.');\n  }\n\n  async schedule(options: ScheduleOptions): Promise<ScheduleResult> {\n    if (!this.hasNotificationSupport()) {\n      throw this.unavailable('Notifications not supported in this browser.');\n    }\n\n    for (const notification of options.notifications) {\n      this.sendNotification(notification);\n    }\n\n    return {\n      notifications: options.notifications.map(notification => ({\n        id: notification.id,\n      })),\n    };\n  }\n\n  async getPending(): Promise<PendingResult> {\n    return {\n      notifications: this.pending,\n    };\n  }\n\n  async registerActionTypes(): Promise<void> {\n    throw this.unimplemented('Not implemented on web.');\n  }\n\n  async cancel(pending: ScheduleResult): Promise<void> {\n    this.pending = this.pending.filter(\n      notification =>\n        !pending.notifications.find(n => n.id === notification.id),\n    );\n  }\n\n  async areEnabled(): Promise<EnabledResult> {\n    const { display } = await this.checkPermissions();\n\n    return {\n      value: display === 'granted',\n    };\n  }\n\n  async changeExactNotificationSetting(): Promise<SettingsPermissionStatus> {\n    throw this.unimplemented('Not implemented on web.');\n  }\n\n  async checkExactNotificationSetting(): Promise<SettingsPermissionStatus> {\n    throw this.unimplemented('Not implemented on web.');\n  }\n\n  async requestPermissions(): Promise<PermissionStatus> {\n    if (!this.hasNotificationSupport()) {\n      throw this.unavailable('Notifications not supported in this browser.');\n    }\n\n    const display = this.transformNotificationPermission(\n      await Notification.requestPermission(),\n    );\n\n    return { display };\n  }\n\n  async checkPermissions(): Promise<PermissionStatus> {\n    if (!this.hasNotificationSupport()) {\n      throw this.unavailable('Notifications not supported in this browser.');\n    }\n\n    const display = this.transformNotificationPermission(\n      Notification.permission,\n    );\n\n    return { display };\n  }\n\n  protected hasNotificationSupport = (): boolean => {\n    if (!('Notification' in window) || !Notification.requestPermission) {\n      return false;\n    }\n\n    if (Notification.permission !== 'granted') {\n      // don't test for `new Notification` if permission has already been granted\n      // otherwise this sends a real notification on supported browsers\n      try {\n        new Notification('');\n      } catch (e) {\n        if (e.name == 'TypeError') {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  };\n\n  protected transformNotificationPermission(\n    permission: NotificationPermission,\n  ): PermissionState {\n    switch (permission) {\n      case 'granted':\n        return 'granted';\n      case 'denied':\n        return 'denied';\n      default:\n        return 'prompt';\n    }\n  }\n\n  protected sendPending(): void {\n    const toRemove: LocalNotificationSchema[] = [];\n    const now = new Date().getTime();\n\n    for (const notification of this.pending) {\n      if (\n        notification.schedule?.at &&\n        notification.schedule.at.getTime() <= now\n      ) {\n        this.buildNotification(notification);\n        toRemove.push(notification);\n      }\n    }\n\n    this.pending = this.pending.filter(\n      notification => !toRemove.find(n => n === notification),\n    );\n  }\n\n  protected sendNotification(notification: LocalNotificationSchema): void {\n    if (notification.schedule?.at) {\n      const diff = notification.schedule.at.getTime() - new Date().getTime();\n\n      this.pending.push(notification);\n      setTimeout(() => {\n        this.sendPending();\n      }, diff);\n      return;\n    }\n    this.buildNotification(notification);\n  }\n\n  protected buildNotification(\n    notification: LocalNotificationSchema,\n  ): Notification {\n    const localNotification = new Notification(notification.title, {\n      body: notification.body,\n      tag: String(notification.id),\n    });\n    localNotification.addEventListener(\n      'click',\n      this.onClick.bind(this, notification),\n      false,\n    );\n    localNotification.addEventListener(\n      'show',\n      this.onShow.bind(this, notification),\n      false,\n    );\n    localNotification.addEventListener(\n      'close',\n      () => {\n        this.deliveredNotifications = this.deliveredNotifications.filter(\n          () => !this,\n        );\n      },\n      false,\n    );\n    this.deliveredNotifications.push(localNotification);\n    return localNotification;\n  }\n\n  protected onClick(notification: LocalNotificationSchema): void {\n    const data = {\n      actionId: 'tap',\n      notification,\n    };\n    this.notifyListeners('localNotificationActionPerformed', data);\n  }\n\n  protected onShow(notification: LocalNotificationSchema): void {\n    this.notifyListeners('localNotificationReceived', notification);\n  }\n}\n"],"names":["parcelRequire","$parcel$global","globalThis","parcelRegister","register","module","exports","Object","defineProperty","get","$802e8b7ef2c3f5ab$export$e6460242ce1a3bfe","set","s","enumerable","configurable","$gJCIb","WebPlugin","arguments","pending","deliveredNotifications","hasNotificationSupport","window","Notification","requestPermission","permission","e","name","getDeliveredNotifications","deliveredSchemas","notification","deliveredSchema","title","id","parseInt","tag","body","push","notifications","removeDeliveredNotifications","delivered","toRemove","found","find","n","String","close","filter","removeAllDeliveredNotifications","createChannel","unimplemented","deleteChannel","listChannels","schedule","options","unavailable","sendNotification","map","getPending","registerActionTypes","cancel","areEnabled","display","checkPermissions","value","changeExactNotificationSetting","checkExactNotificationSetting","requestPermissions","transformNotificationPermission","sendPending","_a","now","Date","getTime","at","buildNotification","diff","setTimeout","localNotification","addEventListener","onClick","bind","onShow","notifyListeners","actionId"],"version":3,"file":"web.393b7de7.js.map"}